# 汇编语言

## 为什么学习汇编



**什么是机器语言？**

> 目前主流的电子计算机，主要是0和1，最早的程序员就是穿孔卡带，计算机扫描，那会就是0,1,0,1
>
> 最基础功能  + - * / 所有的计算都可以用加法运算
>
> 
>
> 助记符--汇编语言，人能够理解的语言转化成机器能够理解的语言
>
> 加 INC --编译器-->0100 0000
>
> 减 DEC ----------->0100 0000
>
> 乘法MUL --编译器-->0100 0000
>
> 除法DIV --编译器-->0100 0000
>
> 汇编一般用于底层的编写，单片机



C语言,由汇编衍生而来

>加 A+B--编译器-->0100 0000
>
>减 A-B ----------->0100 0000
>
>乘法A*B --编译器-->0100 0000
>
>除法A/B --编译器-->0100 0000



## 进制

二进制  0,1

学习进制的障碍，就是因为我们先学习了10进制  二进制，八进制，10进制，16进制



二进制

思想：每一种进制都是完美的，都有自己的计算方式!



1进制：逢一进一  比如古时候 结绳记事，打到就记上一个结

2进制，逢二进一，计算机 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111

八进制，逢八进一  0,1,2,3,4,5,6,7   八个符号组成  0, 1 ,2 ,3 ,4 ,5 ,6 ,7, 10 ,11, 12, 13, 14 ,15, 16, 17, 20, 21, 22 ,23 ,24, 25, 26 ,27, 30,

十进制  逢十进一   0,1,2,3,4,5,6,7,8,9, 10个符号组成

十六进制 缝十六进一   16个符号组成 0 1 2 3 4 5 6 7 8 9 a b c d e f



### 进制怎么运算

```shell
# 八进制计算下面结果

2+3=5
2*3=6
4+5=11
4*5=24

#运算的本质是查数
0 1 2 3 4  5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 40 41 42 43 44 45 46 47

```

| 八进制加法对照表 |        |        |        |        |        |        |        |
| :--------------: | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
|                  |        |        |        |        |        |        |        |
|      0+0=0       |        |        |        |        |        |        |        |
|      1+0=0       | 1+1=2  |        |        |        |        |        |        |
|      2+0=2       | 2+1=3  | 2+2=4  |        |        |        |        |        |
|      3+0=3       | 3+1=4  | 3+2=5  | 3+3=6  |        |        |        |        |
|      4+0=4       | 4+1=5  | 4+2=6  | 4+3=7  | 4+4=10 |        |        |        |
|      5+0=5       | 5+1=6  | 5+2=7  | 5+3=10 | 5+4=11 | 5+5=12 |        |        |
|      6+0=6       | 6+1=7  | 6+2=10 | 6+3=11 | 6+4=12 | 6+5=13 | 6+6=14 |        |
|      7+0=7       | 7+1=10 | 7+2=11 | 7+3=12 | 7+4=13 | 7+5=14 | 7+6=15 | 7+7=16 |

| 八进制乘法对照表 |       |        |        |        |        |        |        |
| ---------------- | ----- | ------ | ------ | ------ | ------ | ------ | ------ |
|                  |       |        |        |        |        |        |        |
| 0*0=0            |       |        |        |        |        |        |        |
| 1*0=0            | 1*1=1 |        |        |        |        |        |        |
| 2*0=0            | 2*1=2 | 2*2=4  |        |        |        |        |        |
| 3*0=0            | 3*1=3 | 3*2=5  | 3*3=11 |        |        |        |        |
| 4*0=0            | 4*1=4 | 4*2=10 | 4*3=14 | 4*4=20 |        |        |        |
| 5*0=0            | 5*1=5 | 5*2=12 | 5*3=17 | 5*4=24 | 5*5=31 |        |        |
| 6*0=6            | 6*1=6 | 6*2=14 | 6*3=22 | 6*4=30 | 6*5=36 | 6*6=44 |        |
| 7*0=0            | 7*1=7 | 7*2=16 | 7*3=25 | 7*4=34 | 7*5=43 | 7*6=52 | 7*7=61 |





### 二进制

学习二进制，是因为计算机使用二进制，0,1，计算机为什么用二进制，因为计算机使用电子，电子只有正点，负电，所以用二进制计算。物理极限，摩尔定律，追求语言的极限!



**量子计算机(传道)**

可以实现量子计算的机器。传统计算机，通过集成电路，使用电子来计算，表现出来0,1 有电无电，高低电平，硅晶片!

量子计算机的单位： 坤比特(qubit) 量子位。 量子的两态来表示

光子  正交偏振方向

磁场 电子的自旋方向



量子计算机，提高计算机的计算力。量子比特，量子叠加态，量子纠缠，量子并行原理

电子计算机---量子计算机



```shell
二进制  0 1111
0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100  1101 1110 1111
```

二进制是否可以简写

```shell
0 1 2 3 4 5 6 7 8 9 a b c d e f  --十六进制，就是为了方便二进制的记忆
```



## 数据宽度



bit   1位

Byte  8位  1个字节

word 16位  2个字节

Dwrod 32位 4个字节

在计算机中，每个数据都需要给他定义类型，关键是为了给他定义宽度，在内存中的宽度!

## 原码 反码 补码



有符号数编码规则

原码   最高位符号位，对其他的为进行本身绝对值即可

反码 

	- 正数  反码和原码相同
	- 负数 符号位为1，其余为对原码取反

补码：

	- 正数  补码和原码相同
	- 负数 符号位一定是1，反码的基础上+1

```shell
# 假设我们在8位操作
# 如果是正数，那就是 原码、反码、补码都一样，没任何区别
例如
1
#原码  0 0 0 0  0 0 0 1
#反码  0 0 0 0  0 0 0 1
#补码  0 0 0 0  0 0 0 1

--->如果是负数， 原码高位为1，反码在原码基础上取反，补码在反码基础+1， 符号位都不变
-1
#原码： 1 0 0 0 0 0 0 1
#反码： 1 1 1 1 1 1 1 0
#补码： 1 1 1 1 1 1 1 1

```

这个内容主要用在位移运算上, 如果看到一个数字，二进制的，需要了解这个数是有符号数还是无符号数。



寄存器:

mov 寄存器 ,值

![image-20201104215802140](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201104215802140.png)

负数在寄存器中是使用补码的方式存储的。



## 位运算

计算机现在可以存储所有的数字，正数，负数都可以存在里面运算(整数，浮点数，字符)，记住位运算

2*8 最高效的运算方式？ 位运算，很多底层的调试器，需要通过位来判断CPU的状态。

**与运算(&  and )**

两个都为1，结果为1

运算底层本质

![image-20201104222101930](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201104222101930.png)

```java
1011 0001
1101 1000
-----------
1001 0000   与运算

    
```



**或运算(|  or)**  只要有一个通就通  有一个为1就是1

计算机本质



![image-20201104222317019](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201104222317019.png)

```shell
1011 0001
1101 1000
-----------
1111 1001   与运算
```



**异或运算( ^ xor)**  不一样就是1，一样就是0

计算机本质

![image-20201104223516700](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201104223516700.png)



```shell
1011 0001
1101 1000
-----------
0110 1001   与运算
```



**非运算( ~ not)**  1就是0  0就是1

一般存数时候，我们负数从原码到反码，需要用到非运算

```shell
1011 0001

-----------
0100 1110   与运算
```

通过这些就可以完成加减乘除，位运算来实现加减乘除



**位运算( shl  移动位)**



左移  (shl <<)  

```shell
0000 0001 @所有二进制位全部左移若干位， 高位就丢弃了，低位补0
0000 0010  
```



右移(shr >>)

```shell
0000 0001 @所有二进制位全部右移若干位， 低位就丢弃了，高位需要补0,1(符号位决定如何补位)
0000 0000  
------------
0
printf("%d\n" a>>2)
```



```shell
0000 0001                   1
0000 0010   左移1位  增长一倍  2
0000 0100   左移两位  增长2倍  4
0000 1000   左移两位  增长4倍  8


public class TestCompile {
    public static void main(String[] args) {
        int a = 47484330;//二进制  10 1101 0100 1000 1101 1010 1010
        a=a>>2;  // 0010 1101 0100 1000 1101 1010 10
        System.out.println(a);
    }
}

```

## 位运算的加减乘除



计算机只认识 0  1 ，但是基本数学是建立在 加减乘除上，只要加法做到， 减法也可以，乘法也可以，除法也可以

4+5？



```shell
#计算机怎么操作的
4  -->  0000  0100
5  -->  0000  0101
----------------------（加法，计算机不会直接加）

#  怎么让计算机识别这个过程
# 计算机实现原理
# 第一步 异或运算 不考虑进位，亦或就可以直接出结果(不一样为1，一样为0) (xor ^)
4  -->  0000  0100
5  -->  0000  0101
----------------------
0000 0001 

# 第二步 将两个数进行与运算（判断进位） 因为两个数的第三位 亦或之后，有进位，所以需要与运算，如果与运算结果为0，就没有进位，只要不为0，那就是有进位  and &
0000  0100
0000  0101
-------------(与运算，都为1就是1)
0000 0100

# 第三步 ，将与运算的结果，左移一位
0000 0100 << 1   = 0000 1000

# 第四步  将第一步亦或运算后的结果和第三步左移一位的结果再次进行 亦或运算
0000 0001 
0000 1000
----------------
0000 1001    最终结果

# 第五步 确认结果是否正确，将第一步亦或运算的结果和第三步左移一位的结果进行再次进行与运算 判断第四位是否有进位

0000 0001 
0000 1000
----------------
0000 0000 

经过上述运算结果为0，计算机确认最终结果为 0000 1001 

0000  0100  + 0000  0101 = 0000 1001 
```



**减法运算 4-5**



```shell
#计算机怎么操作的  
4-5=5+(-5)
4  -->  0000  0100
5  -->  0000  0101  取反：1111 1010 取补码(反码+1)： 1111 1011
----------------------（减法，计算机不会直接加）

#  怎么让计算机识别这个过程
# 计算机实现原理
# 第一步 异或运算 不考虑进位，亦或就可以直接出结果(不一样为1，一样为0) (xor ^)
0000 0100
1111 1011
----------------------
1111 1111  ff 代表-1

# 第二步 与运算（判断进位） 因为两个数的第三位 亦或之后，有进位，所以需要与运算，如果与运算结果为0，就没有进位，只要不为0，那就是有进位  and &
0000 0100
1111 1011
-------------(与运算，都为1就是1)
0000 0000


经过上述与结果，没有进位，计算机确认最终结果为 1111 1111

0000  0100  +1111 1011 = 1111 1111
# 符号位又来了
```



乘法 x*y  就是Y个X相加，还是加法



除法，X/Y 本质就是减法，就只X中能减去多少个Y。又还是加法

![image-20201104233028825](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201104233028825.png)

## 寄存器 内存 汇编指令



**通用寄存器**

存储数据 CPU---内存---硬盘，CPU分为32位CPU和64位CPU， 32位CPU分为 8,16,32位   64位CPU分 8,16,32,64位



> 32位通用寄存器有8个，分别为 EAX，EBX ECX EDX  ESP  EBP  ESI  EDI EAX，存值范围 0~FFFFFF

EBX ECX EDX  ESP  EBP  ESI  EDI

计算机如何向寄存器存值？



对于二进制来说，直接修改值，找到对应位置(内存地址)

mov 指令   mov EBX ,FFFFFF  或者MOV EBX AX，MOV EAX 0X2,  MOX EDX, ECX;

指令格式:MOV 存的地址，存的数 或者 mov 存在地址1，存的地址2

```shell
8F		4F		  2F		0000 0000
32位		16位		8位
EAX		AX		  AL
ECX		BX		  CL
EDX		CX		  DL
EBX		DX		  BL
ESP		SP		  AH
EBP		BP		  CH
ESI		SI		  DH
EDI		DI		  BH
```

8位：L代表低8位， H代表高8位

除了通用寄存器之外，其他的寄存器每一位都有自己的特定功能，我们写值一般写入到通用寄存器中



**内存**

寄存器很小，不够用，所以说，数据放到内存中!

每个应用程序进程都有4GB的内存空间，但实际是虚拟内存，并不是物理内存。程序真正运行的时候，才会用到物理内存。

1Byte  = 8bit

1kb = 1024b

1mb =1024kb

1gb =1024mb

假设4G内存，=4096mb-->最终计算为位就是可以存储的最大容量的。计算机中内存地址很多，空间很大



**内存地址**

存一个数，占用的打下，数据宽度! 存到内存里! 给每个空间分配一个地址，名字。

32位 8个F，FFFFFFFF， 一个F4位  f=1111

32决定我们的寻址能力! 64位地址，内存可以拓展无限大

FFFFFFFF+1 =0x100000000  最大的值

位是如何限制内存的大小。

100000000 内存地址*8 =位  800000000

转换为10进制/8  

内存如何存值?  

存值需要知道数据宽度，(byte- word-dword)+地址位置 ,就可以通过汇编写入到内存

![image-20201105145500152](F:\MD格式学习笔记库\狂神JAVA-6-汇编语言.assets\image-20201105145500152.png)



向内存写入数据的方式

```shell
mov 数据宽度 内存地址,1 例如:

mov byte ptr ds:[00195570], 0x01

```



内存地址有多重写法，例如

方式一：内存地址便宜	ds:[00195570+4]   取得 00195574

方式二：放寄存器  ds:[eax] 

方法三:  寄存器偏移  ds:[eax+4] 

数组[]

ds:[reg+reg*(1,2,4,8)]





汇编指令



内存复制



堆栈的指令





汇编如何写函数



堆栈传参



堆栈平衡



外挂











